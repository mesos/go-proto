// Code generated by protoc-gen-go. DO NOT EDIT.
// source: executor.proto

package mesos_v1_executor

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v1 "github.com/mesos/go-proto/mesos/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Possible event types, followed by message definitions if
// applicable.
type Event_Type int32

const (
	// This must be the first enum value in this list, to
	// ensure that if 'type' is not set, the default value
	// is UNKNOWN. This enables enum values to be added
	// in a backwards-compatible way. See: MESOS-4997.
	Event_UNKNOWN      Event_Type = 0
	Event_SUBSCRIBED   Event_Type = 1
	Event_LAUNCH       Event_Type = 2
	Event_LAUNCH_GROUP Event_Type = 8
	Event_KILL         Event_Type = 3
	Event_ACKNOWLEDGED Event_Type = 4
	Event_MESSAGE      Event_Type = 5
	Event_ERROR        Event_Type = 6
	// Received when the agent asks the executor to shutdown/kill itself.
	// The executor is then required to kill all its active tasks, send
	// `TASK_KILLED` status updates and gracefully exit. The executor
	// should terminate within a `MESOS_EXECUTOR_SHUTDOWN_GRACE_PERIOD`
	// (an environment variable set by the agent upon executor startup);
	// it can be configured via `ExecutorInfo.shutdown_grace_period`. If
	// the executor fails to do so, the agent will forcefully destroy the
	// container where the executor is running. The agent would then send
	// `TASK_LOST` updates for any remaining active tasks of this executor.
	//
	// NOTE: The executor must not assume that it will always be allotted
	// the full grace period, as the agent may decide to allot a shorter
	// period and failures / forcible terminations may occur.
	//
	// TODO(alexr): Consider adding a duration field into the `Shutdown`
	// message so that the agent can communicate when a shorter period
	// has been allotted.
	Event_SHUTDOWN Event_Type = 7
	// Received periodically to make sure the connection is alive and to
	// prevent any possible network intermediaries from marking the
	// connection as stale (when there are no other messages being sent).
	Event_HEARTBEAT Event_Type = 9
)

var Event_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "SUBSCRIBED",
	2: "LAUNCH",
	8: "LAUNCH_GROUP",
	3: "KILL",
	4: "ACKNOWLEDGED",
	5: "MESSAGE",
	6: "ERROR",
	7: "SHUTDOWN",
	9: "HEARTBEAT",
}

var Event_Type_value = map[string]int32{
	"UNKNOWN":      0,
	"SUBSCRIBED":   1,
	"LAUNCH":       2,
	"LAUNCH_GROUP": 8,
	"KILL":         3,
	"ACKNOWLEDGED": 4,
	"MESSAGE":      5,
	"ERROR":        6,
	"SHUTDOWN":     7,
	"HEARTBEAT":    9,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}

func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}

func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}

func (Event_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 0}
}

// Possible call types, followed by message definitions if
// applicable.
type Call_Type int32

const (
	// See comments above on `Event::Type` for more details on this enum value.
	Call_UNKNOWN   Call_Type = 0
	Call_SUBSCRIBE Call_Type = 1
	Call_UPDATE    Call_Type = 2
	Call_MESSAGE   Call_Type = 3
	// Optional message that can be used to make sure the executor's
	// connection is still alive and to prevent any possible network
	// intermediaries from marking the connection as stale (when there
	// are no other messages being sent). Heartbeats are only necessary
	// if the executor uses a persistent connection to send calls.
	Call_HEARTBEAT Call_Type = 4
)

var Call_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "SUBSCRIBE",
	2: "UPDATE",
	3: "MESSAGE",
	4: "HEARTBEAT",
}

var Call_Type_value = map[string]int32{
	"UNKNOWN":   0,
	"SUBSCRIBE": 1,
	"UPDATE":    2,
	"MESSAGE":   3,
	"HEARTBEAT": 4,
}

func (x Call_Type) Enum() *Call_Type {
	p := new(Call_Type)
	*p = x
	return p
}

func (x Call_Type) String() string {
	return proto.EnumName(Call_Type_name, int32(x))
}

func (x *Call_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Call_Type_value, data, "Call_Type")
	if err != nil {
		return err
	}
	*x = Call_Type(value)
	return nil
}

func (Call_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1, 0}
}

//*
// Executor event API.
//
// An event is described using the standard protocol buffer "union"
// trick, see https://developers.google.com/protocol-buffers/docs/techniques#union.
type Event struct {
	// Type of the event, indicates which optional field below should be
	// present if that type has a nested message definition.
	// Enum fields should be optional, see: MESOS-4997.
	Type                 *Event_Type         `protobuf:"varint,1,opt,name=type,enum=mesos.v1.executor.Event_Type" json:"type,omitempty"`
	Subscribed           *Event_Subscribed   `protobuf:"bytes,2,opt,name=subscribed" json:"subscribed,omitempty"`
	Acknowledged         *Event_Acknowledged `protobuf:"bytes,3,opt,name=acknowledged" json:"acknowledged,omitempty"`
	Launch               *Event_Launch       `protobuf:"bytes,4,opt,name=launch" json:"launch,omitempty"`
	LaunchGroup          *Event_LaunchGroup  `protobuf:"bytes,8,opt,name=launch_group,json=launch_group" json:"launch_group,omitempty"`
	Kill                 *Event_Kill         `protobuf:"bytes,5,opt,name=kill" json:"kill,omitempty"`
	Message              *Event_Message      `protobuf:"bytes,6,opt,name=message" json:"message,omitempty"`
	Error                *Event_Error        `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_UNKNOWN
}

func (m *Event) GetSubscribed() *Event_Subscribed {
	if m != nil {
		return m.Subscribed
	}
	return nil
}

func (m *Event) GetAcknowledged() *Event_Acknowledged {
	if m != nil {
		return m.Acknowledged
	}
	return nil
}

func (m *Event) GetLaunch() *Event_Launch {
	if m != nil {
		return m.Launch
	}
	return nil
}

func (m *Event) GetLaunchGroup() *Event_LaunchGroup {
	if m != nil {
		return m.LaunchGroup
	}
	return nil
}

func (m *Event) GetKill() *Event_Kill {
	if m != nil {
		return m.Kill
	}
	return nil
}

func (m *Event) GetMessage() *Event_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Event) GetError() *Event_Error {
	if m != nil {
		return m.Error
	}
	return nil
}

// First event received when the executor subscribes.
// The 'id' field in the 'framework_info' will be set.
type Event_Subscribed struct {
	ExecutorInfo  *v1.ExecutorInfo  `protobuf:"bytes,1,req,name=executor_info,json=executor_info" json:"executor_info,omitempty"`
	FrameworkInfo *v1.FrameworkInfo `protobuf:"bytes,2,req,name=framework_info,json=framework_info" json:"framework_info,omitempty"`
	AgentInfo     *v1.AgentInfo     `protobuf:"bytes,3,req,name=agent_info,json=agent_info" json:"agent_info,omitempty"`
	// Uniquely identifies the container of an executor run.
	ContainerId          *v1.ContainerID `protobuf:"bytes,4,opt,name=container_id,json=container_id" json:"container_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Event_Subscribed) Reset()         { *m = Event_Subscribed{} }
func (m *Event_Subscribed) String() string { return proto.CompactTextString(m) }
func (*Event_Subscribed) ProtoMessage()    {}
func (*Event_Subscribed) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 0}
}

func (m *Event_Subscribed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_Subscribed.Unmarshal(m, b)
}
func (m *Event_Subscribed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_Subscribed.Marshal(b, m, deterministic)
}
func (m *Event_Subscribed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Subscribed.Merge(m, src)
}
func (m *Event_Subscribed) XXX_Size() int {
	return xxx_messageInfo_Event_Subscribed.Size(m)
}
func (m *Event_Subscribed) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Subscribed.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Subscribed proto.InternalMessageInfo

func (m *Event_Subscribed) GetExecutorInfo() *v1.ExecutorInfo {
	if m != nil {
		return m.ExecutorInfo
	}
	return nil
}

func (m *Event_Subscribed) GetFrameworkInfo() *v1.FrameworkInfo {
	if m != nil {
		return m.FrameworkInfo
	}
	return nil
}

func (m *Event_Subscribed) GetAgentInfo() *v1.AgentInfo {
	if m != nil {
		return m.AgentInfo
	}
	return nil
}

func (m *Event_Subscribed) GetContainerId() *v1.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

// Received when the framework attempts to launch a task. Once
// the task is successfully launched, the executor must respond with
// a TASK_RUNNING update (See TaskState in v1/mesos.proto).
type Event_Launch struct {
	Task                 *v1.TaskInfo `protobuf:"bytes,1,req,name=task" json:"task,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Event_Launch) Reset()         { *m = Event_Launch{} }
func (m *Event_Launch) String() string { return proto.CompactTextString(m) }
func (*Event_Launch) ProtoMessage()    {}
func (*Event_Launch) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 1}
}

func (m *Event_Launch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_Launch.Unmarshal(m, b)
}
func (m *Event_Launch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_Launch.Marshal(b, m, deterministic)
}
func (m *Event_Launch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Launch.Merge(m, src)
}
func (m *Event_Launch) XXX_Size() int {
	return xxx_messageInfo_Event_Launch.Size(m)
}
func (m *Event_Launch) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Launch.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Launch proto.InternalMessageInfo

func (m *Event_Launch) GetTask() *v1.TaskInfo {
	if m != nil {
		return m.Task
	}
	return nil
}

// Received when the framework attempts to launch a group of tasks atomically.
// Similar to `Launch` above the executor must send TASK_RUNNING updates for
// tasks that are successfully launched.
type Event_LaunchGroup struct {
	TaskGroup            *v1.TaskGroupInfo `protobuf:"bytes,1,req,name=task_group,json=task_group" json:"task_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Event_LaunchGroup) Reset()         { *m = Event_LaunchGroup{} }
func (m *Event_LaunchGroup) String() string { return proto.CompactTextString(m) }
func (*Event_LaunchGroup) ProtoMessage()    {}
func (*Event_LaunchGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 2}
}

func (m *Event_LaunchGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_LaunchGroup.Unmarshal(m, b)
}
func (m *Event_LaunchGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_LaunchGroup.Marshal(b, m, deterministic)
}
func (m *Event_LaunchGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_LaunchGroup.Merge(m, src)
}
func (m *Event_LaunchGroup) XXX_Size() int {
	return xxx_messageInfo_Event_LaunchGroup.Size(m)
}
func (m *Event_LaunchGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_LaunchGroup.DiscardUnknown(m)
}

var xxx_messageInfo_Event_LaunchGroup proto.InternalMessageInfo

func (m *Event_LaunchGroup) GetTaskGroup() *v1.TaskGroupInfo {
	if m != nil {
		return m.TaskGroup
	}
	return nil
}

// Received when the scheduler wants to kill a specific task. Once
// the task is terminated, the executor should send a TASK_KILLED
// (or TASK_FAILED) update. The terminal update is necessary so
// Mesos can release the resources associated with the task.
type Event_Kill struct {
	TaskId *v1.TaskID `protobuf:"bytes,1,req,name=task_id,json=task_id" json:"task_id,omitempty"`
	// If set, overrides any previously specified kill policy for this task.
	// This includes 'TaskInfo.kill_policy' and 'Executor.kill.kill_policy'.
	// Can be used to forcefully kill a task which is already being killed.
	KillPolicy           *v1.KillPolicy `protobuf:"bytes,2,opt,name=kill_policy,json=kill_policy" json:"kill_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Event_Kill) Reset()         { *m = Event_Kill{} }
func (m *Event_Kill) String() string { return proto.CompactTextString(m) }
func (*Event_Kill) ProtoMessage()    {}
func (*Event_Kill) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 3}
}

func (m *Event_Kill) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_Kill.Unmarshal(m, b)
}
func (m *Event_Kill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_Kill.Marshal(b, m, deterministic)
}
func (m *Event_Kill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Kill.Merge(m, src)
}
func (m *Event_Kill) XXX_Size() int {
	return xxx_messageInfo_Event_Kill.Size(m)
}
func (m *Event_Kill) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Kill.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Kill proto.InternalMessageInfo

func (m *Event_Kill) GetTaskId() *v1.TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Event_Kill) GetKillPolicy() *v1.KillPolicy {
	if m != nil {
		return m.KillPolicy
	}
	return nil
}

// Received when the agent acknowledges the receipt of status
// update. Schedulers are responsible for explicitly acknowledging
// the receipt of status updates that have 'update.status().uuid()'
// field set. Unacknowledged updates can be retried by the executor.
// They should also be sent by the executor whenever it
// re-subscribes.
type Event_Acknowledged struct {
	TaskId               *v1.TaskID `protobuf:"bytes,1,req,name=task_id,json=task_id" json:"task_id,omitempty"`
	Uuid                 []byte     `protobuf:"bytes,2,req,name=uuid" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Event_Acknowledged) Reset()         { *m = Event_Acknowledged{} }
func (m *Event_Acknowledged) String() string { return proto.CompactTextString(m) }
func (*Event_Acknowledged) ProtoMessage()    {}
func (*Event_Acknowledged) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 4}
}

func (m *Event_Acknowledged) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_Acknowledged.Unmarshal(m, b)
}
func (m *Event_Acknowledged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_Acknowledged.Marshal(b, m, deterministic)
}
func (m *Event_Acknowledged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Acknowledged.Merge(m, src)
}
func (m *Event_Acknowledged) XXX_Size() int {
	return xxx_messageInfo_Event_Acknowledged.Size(m)
}
func (m *Event_Acknowledged) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Acknowledged.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Acknowledged proto.InternalMessageInfo

func (m *Event_Acknowledged) GetTaskId() *v1.TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Event_Acknowledged) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

// Received when a custom message generated by the scheduler is
// forwarded by the agent. Note that this message is not
// interpreted by Mesos and is only forwarded (without reliability
// guarantees) to the executor. It is up to the scheduler to retry
// if the message is dropped for any reason.
type Event_Message struct {
	Data                 []byte   `protobuf:"bytes,1,req,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event_Message) Reset()         { *m = Event_Message{} }
func (m *Event_Message) String() string { return proto.CompactTextString(m) }
func (*Event_Message) ProtoMessage()    {}
func (*Event_Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 5}
}

func (m *Event_Message) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_Message.Unmarshal(m, b)
}
func (m *Event_Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_Message.Marshal(b, m, deterministic)
}
func (m *Event_Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Message.Merge(m, src)
}
func (m *Event_Message) XXX_Size() int {
	return xxx_messageInfo_Event_Message.Size(m)
}
func (m *Event_Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Message proto.InternalMessageInfo

func (m *Event_Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Received in case the executor sends invalid calls (e.g.,
// required values not set).
// TODO(arojas): Remove this once the old executor driver is no
// longer supported. With HTTP API all errors will be signaled via
// HTTP response codes.
type Event_Error struct {
	Message              *string  `protobuf:"bytes,1,req,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event_Error) Reset()         { *m = Event_Error{} }
func (m *Event_Error) String() string { return proto.CompactTextString(m) }
func (*Event_Error) ProtoMessage()    {}
func (*Event_Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0, 6}
}

func (m *Event_Error) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event_Error.Unmarshal(m, b)
}
func (m *Event_Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event_Error.Marshal(b, m, deterministic)
}
func (m *Event_Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Error.Merge(m, src)
}
func (m *Event_Error) XXX_Size() int {
	return xxx_messageInfo_Event_Error.Size(m)
}
func (m *Event_Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Error proto.InternalMessageInfo

func (m *Event_Error) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

//*
// Executor call API.
//
// Like Event, a Call is described using the standard protocol buffer
// "union" trick (see above).
type Call struct {
	// Identifies the executor which generated this call.
	ExecutorId  *v1.ExecutorID  `protobuf:"bytes,1,req,name=executor_id,json=executor_id" json:"executor_id,omitempty"`
	FrameworkId *v1.FrameworkID `protobuf:"bytes,2,req,name=framework_id,json=framework_id" json:"framework_id,omitempty"`
	// Type of the call, indicates which optional field below should be
	// present if that type has a nested message definition.
	// In case type is SUBSCRIBED, no message needs to be set.
	// See comments on `Event::Type` above on the reasoning behind this
	// field being optional.
	Type                 *Call_Type      `protobuf:"varint,3,opt,name=type,enum=mesos.v1.executor.Call_Type" json:"type,omitempty"`
	Subscribe            *Call_Subscribe `protobuf:"bytes,4,opt,name=subscribe" json:"subscribe,omitempty"`
	Update               *Call_Update    `protobuf:"bytes,5,opt,name=update" json:"update,omitempty"`
	Message              *Call_Message   `protobuf:"bytes,6,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Call) Reset()         { *m = Call{} }
func (m *Call) String() string { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()    {}
func (*Call) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1}
}

func (m *Call) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Call.Unmarshal(m, b)
}
func (m *Call) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Call.Marshal(b, m, deterministic)
}
func (m *Call) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Call.Merge(m, src)
}
func (m *Call) XXX_Size() int {
	return xxx_messageInfo_Call.Size(m)
}
func (m *Call) XXX_DiscardUnknown() {
	xxx_messageInfo_Call.DiscardUnknown(m)
}

var xxx_messageInfo_Call proto.InternalMessageInfo

func (m *Call) GetExecutorId() *v1.ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *Call) GetFrameworkId() *v1.FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Call) GetType() Call_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Call_UNKNOWN
}

func (m *Call) GetSubscribe() *Call_Subscribe {
	if m != nil {
		return m.Subscribe
	}
	return nil
}

func (m *Call) GetUpdate() *Call_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Call) GetMessage() *Call_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

// Request to subscribe with the agent. If subscribing after a disconnection,
// it must include a list of all the tasks and updates which haven't been
// acknowledged by the scheduler.
type Call_Subscribe struct {
	UnacknowledgedTasks   []*v1.TaskInfo `protobuf:"bytes,1,rep,name=unacknowledged_tasks,json=unacknowledged_tasks" json:"unacknowledged_tasks,omitempty"`
	UnacknowledgedUpdates []*Call_Update `protobuf:"bytes,2,rep,name=unacknowledged_updates,json=unacknowledged_updates" json:"unacknowledged_updates,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}       `json:"-"`
	XXX_unrecognized      []byte         `json:"-"`
	XXX_sizecache         int32          `json:"-"`
}

func (m *Call_Subscribe) Reset()         { *m = Call_Subscribe{} }
func (m *Call_Subscribe) String() string { return proto.CompactTextString(m) }
func (*Call_Subscribe) ProtoMessage()    {}
func (*Call_Subscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1, 0}
}

func (m *Call_Subscribe) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Call_Subscribe.Unmarshal(m, b)
}
func (m *Call_Subscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Call_Subscribe.Marshal(b, m, deterministic)
}
func (m *Call_Subscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Call_Subscribe.Merge(m, src)
}
func (m *Call_Subscribe) XXX_Size() int {
	return xxx_messageInfo_Call_Subscribe.Size(m)
}
func (m *Call_Subscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_Call_Subscribe.DiscardUnknown(m)
}

var xxx_messageInfo_Call_Subscribe proto.InternalMessageInfo

func (m *Call_Subscribe) GetUnacknowledgedTasks() []*v1.TaskInfo {
	if m != nil {
		return m.UnacknowledgedTasks
	}
	return nil
}

func (m *Call_Subscribe) GetUnacknowledgedUpdates() []*Call_Update {
	if m != nil {
		return m.UnacknowledgedUpdates
	}
	return nil
}

// Notifies the scheduler that a task has transitioned from one
// state to another. Status updates should be used by executors
// to reliably communicate the status of the tasks that they
// manage. It is crucial that a terminal update (see TaskState
// in v1/mesos.proto) is sent to the scheduler as soon as the task
// terminates, in order for Mesos to release the resources allocated
// to the task. It is the responsibility of the scheduler to
// explicitly acknowledge the receipt of a status update. See
// 'Acknowledged' in the 'Events' section above for the semantics.
type Call_Update struct {
	Status               *v1.TaskStatus `protobuf:"bytes,1,req,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Call_Update) Reset()         { *m = Call_Update{} }
func (m *Call_Update) String() string { return proto.CompactTextString(m) }
func (*Call_Update) ProtoMessage()    {}
func (*Call_Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1, 1}
}

func (m *Call_Update) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Call_Update.Unmarshal(m, b)
}
func (m *Call_Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Call_Update.Marshal(b, m, deterministic)
}
func (m *Call_Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Call_Update.Merge(m, src)
}
func (m *Call_Update) XXX_Size() int {
	return xxx_messageInfo_Call_Update.Size(m)
}
func (m *Call_Update) XXX_DiscardUnknown() {
	xxx_messageInfo_Call_Update.DiscardUnknown(m)
}

var xxx_messageInfo_Call_Update proto.InternalMessageInfo

func (m *Call_Update) GetStatus() *v1.TaskStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Sends arbitrary binary data to the scheduler. Note that Mesos
// neither interprets this data nor makes any guarantees about the
// delivery of this message to the scheduler.
// See 'Message' in the 'Events' section.
type Call_Message struct {
	Data                 []byte   `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Call_Message) Reset()         { *m = Call_Message{} }
func (m *Call_Message) String() string { return proto.CompactTextString(m) }
func (*Call_Message) ProtoMessage()    {}
func (*Call_Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1, 2}
}

func (m *Call_Message) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Call_Message.Unmarshal(m, b)
}
func (m *Call_Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Call_Message.Marshal(b, m, deterministic)
}
func (m *Call_Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Call_Message.Merge(m, src)
}
func (m *Call_Message) XXX_Size() int {
	return xxx_messageInfo_Call_Message.Size(m)
}
func (m *Call_Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Call_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Call_Message proto.InternalMessageInfo

func (m *Call_Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("mesos.v1.executor.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("mesos.v1.executor.Call_Type", Call_Type_name, Call_Type_value)
	proto.RegisterType((*Event)(nil), "mesos.v1.executor.Event")
	proto.RegisterType((*Event_Subscribed)(nil), "mesos.v1.executor.Event.Subscribed")
	proto.RegisterType((*Event_Launch)(nil), "mesos.v1.executor.Event.Launch")
	proto.RegisterType((*Event_LaunchGroup)(nil), "mesos.v1.executor.Event.LaunchGroup")
	proto.RegisterType((*Event_Kill)(nil), "mesos.v1.executor.Event.Kill")
	proto.RegisterType((*Event_Acknowledged)(nil), "mesos.v1.executor.Event.Acknowledged")
	proto.RegisterType((*Event_Message)(nil), "mesos.v1.executor.Event.Message")
	proto.RegisterType((*Event_Error)(nil), "mesos.v1.executor.Event.Error")
	proto.RegisterType((*Call)(nil), "mesos.v1.executor.Call")
	proto.RegisterType((*Call_Subscribe)(nil), "mesos.v1.executor.Call.Subscribe")
	proto.RegisterType((*Call_Update)(nil), "mesos.v1.executor.Call.Update")
	proto.RegisterType((*Call_Message)(nil), "mesos.v1.executor.Call.Message")
}

func init() { proto.RegisterFile("executor.proto", fileDescriptor_12d1cdcda51e000f) }

var fileDescriptor_12d1cdcda51e000f = []byte{
	// 869 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x95, 0xeb, 0x6e, 0xe2, 0x46,
	0x14, 0xc7, 0x6b, 0x30, 0x26, 0x1c, 0x9c, 0xc8, 0x3d, 0x9b, 0x6c, 0x2d, 0x6b, 0x2f, 0x6c, 0xda,
	0xae, 0x52, 0xa9, 0x62, 0x37, 0x51, 0x9b, 0xde, 0xa4, 0x56, 0x80, 0x5d, 0x42, 0x43, 0x2e, 0x1a,
	0x40, 0xfd, 0x88, 0x66, 0xf1, 0x84, 0x58, 0x38, 0x36, 0xf2, 0x25, 0xdb, 0xbc, 0x46, 0xdf, 0xa2,
	0x52, 0x1f, 0xaf, 0x52, 0xbf, 0x56, 0x33, 0x36, 0xb6, 0x21, 0x58, 0x51, 0xbf, 0xcd, 0xcc, 0xf9,
	0xff, 0x8e, 0xe7, 0xf2, 0x3f, 0xc7, 0xb0, 0xc7, 0xfe, 0x60, 0xb3, 0x38, 0xf2, 0x83, 0xf6, 0x32,
	0xf0, 0x23, 0x1f, 0x3f, 0xbd, 0x63, 0xa1, 0x1f, 0xb6, 0xef, 0x8f, 0xdb, 0xab, 0x80, 0xb1, 0x2f,
	0x96, 0xde, 0xdd, 0x1f, 0xbf, 0x4b, 0x62, 0x42, 0x78, 0xf8, 0x4f, 0x03, 0x6a, 0xd6, 0x3d, 0xf3,
	0x22, 0x3c, 0x06, 0x39, 0x7a, 0x58, 0x32, 0x5d, 0x6a, 0x49, 0x47, 0x7b, 0x27, 0x2f, 0xdb, 0x8f,
	0x32, 0xb4, 0x85, 0xae, 0x3d, 0x7e, 0x58, 0x32, 0x22, 0xa4, 0xd8, 0x03, 0x08, 0xe3, 0x0f, 0xe1,
	0x2c, 0x70, 0x3e, 0x30, 0x5b, 0xaf, 0xb4, 0xa4, 0xa3, 0xe6, 0xc9, 0xe7, 0xa5, 0xe0, 0x28, 0x93,
	0x92, 0x02, 0x86, 0x03, 0x50, 0xe9, 0x6c, 0xe1, 0xf9, 0x1f, 0x5d, 0x66, 0xcf, 0x99, 0xad, 0x57,
	0x45, 0x9a, 0x2f, 0x4b, 0xd3, 0x74, 0x0a, 0x62, 0xb2, 0x86, 0xe2, 0x77, 0xa0, 0xb8, 0x34, 0xf6,
	0x66, 0xb7, 0xba, 0x2c, 0x92, 0xbc, 0x2e, 0x4d, 0x32, 0x14, 0x32, 0x92, 0xca, 0xb1, 0x0f, 0x6a,
	0x32, 0x9a, 0xce, 0x03, 0x3f, 0x5e, 0xea, 0x3b, 0x02, 0xff, 0xe2, 0x09, 0xbc, 0xcf, 0xb5, 0xa4,
	0xe9, 0xe6, 0x13, 0x7e, 0x89, 0x0b, 0xc7, 0x75, 0xf5, 0x9a, 0x48, 0x50, 0x7e, 0x89, 0xe7, 0x8e,
	0xeb, 0x12, 0x21, 0xc5, 0x1f, 0xa1, 0x7e, 0xc7, 0xc2, 0x90, 0xce, 0x99, 0xae, 0x08, 0xaa, 0x55,
	0x4a, 0x5d, 0x24, 0x3a, 0xb2, 0x02, 0xf0, 0x1b, 0xa8, 0xb1, 0x20, 0xf0, 0x03, 0xbd, 0x2e, 0xc8,
	0x57, 0xa5, 0xa4, 0xc5, 0x55, 0x24, 0x11, 0x1b, 0xff, 0x4a, 0x00, 0xf9, 0x63, 0xe0, 0x4f, 0xb0,
	0xbb, 0x52, 0x4f, 0x1d, 0xef, 0xc6, 0xd7, 0xa5, 0x56, 0xe5, 0xa8, 0x79, 0xf2, 0x3c, 0x4f, 0x66,
	0xa5, 0xe1, 0x81, 0x77, 0xe3, 0x13, 0x95, 0x15, 0x66, 0xf8, 0x33, 0xec, 0xdd, 0x04, 0xf4, 0x8e,
	0x7d, 0xf4, 0x83, 0x45, 0x42, 0x57, 0x04, 0xfd, 0x59, 0x4e, 0xff, 0xba, 0x8a, 0x0b, 0x7c, 0xf7,
	0xa6, 0x38, 0xc5, 0x13, 0x00, 0x3a, 0x67, 0x5e, 0x94, 0xb0, 0x55, 0xc1, 0x3e, 0xcb, 0xd9, 0x0e,
	0x8f, 0x09, 0xae, 0x41, 0x57, 0x43, 0xfc, 0x1e, 0xd4, 0x99, 0xef, 0x45, 0xd4, 0xf1, 0x58, 0x30,
	0x75, 0xec, 0xf4, 0xb1, 0x0f, 0x72, 0xaa, 0xb7, 0x8a, 0x0e, 0x4c, 0xd2, 0xcc, 0xa4, 0x03, 0xdb,
	0x78, 0x0f, 0x4a, 0xf2, 0x74, 0xf8, 0x16, 0xe4, 0x88, 0x86, 0x8b, 0xf4, 0xac, 0x98, 0xb3, 0x63,
	0x1a, 0x26, 0x1b, 0x15, 0x71, 0xc3, 0x82, 0x66, 0xe1, 0xb1, 0xf1, 0x14, 0x80, 0x2f, 0xa7, 0x36,
	0x91, 0x36, 0x8f, 0xca, 0x61, 0x21, 0x4c, 0xb6, 0x1c, 0xad, 0xa6, 0xc6, 0x2d, 0xc8, 0xfc, 0xc9,
	0xf1, 0x2b, 0xa8, 0x0b, 0xde, 0xb1, 0x53, 0x58, 0xdb, 0xf8, 0xb2, 0x49, 0x14, 0x2e, 0x18, 0xd8,
	0xf8, 0x2d, 0x34, 0xb9, 0x3f, 0xa6, 0x4b, 0xdf, 0x75, 0x66, 0x0f, 0x69, 0x75, 0xed, 0xe7, 0x72,
	0x9e, 0xef, 0x5a, 0xc4, 0x08, 0x2c, 0xb2, 0xb1, 0x71, 0x01, 0x6a, 0xb1, 0x42, 0xfe, 0xcf, 0x17,
	0x11, 0xe4, 0x38, 0x76, 0x6c, 0xf1, 0x82, 0x2a, 0x11, 0x63, 0xe3, 0x25, 0xd4, 0x53, 0xd7, 0xf1,
	0xb0, 0x4d, 0x23, 0x2a, 0xd2, 0xa8, 0x44, 0x8c, 0x8d, 0x37, 0x50, 0x13, 0xd6, 0x42, 0x3d, 0x77,
	0x31, 0x8f, 0x37, 0x32, 0x8f, 0x1e, 0xfe, 0x29, 0x81, 0xcc, 0x7b, 0x06, 0x36, 0xa1, 0x3e, 0xb9,
	0x3c, 0xbf, 0xbc, 0xfa, 0xfd, 0x52, 0xfb, 0x04, 0xf7, 0x00, 0x46, 0x93, 0xee, 0xa8, 0x47, 0x06,
	0x5d, 0xcb, 0xd4, 0x24, 0x04, 0x50, 0x86, 0x9d, 0xc9, 0x65, 0xef, 0x4c, 0xab, 0xa0, 0x06, 0x6a,
	0x32, 0x9e, 0xf6, 0xc9, 0xd5, 0xe4, 0x5a, 0xdb, 0xc1, 0x1d, 0x90, 0xcf, 0x07, 0xc3, 0xa1, 0x56,
	0xe5, 0xb1, 0x4e, 0x8f, 0x27, 0x19, 0x5a, 0x66, 0xdf, 0x32, 0x35, 0x99, 0xa7, 0xbd, 0xb0, 0x46,
	0xa3, 0x4e, 0xdf, 0xd2, 0x6a, 0xc8, 0xbb, 0x19, 0x21, 0x57, 0x44, 0x53, 0x50, 0x85, 0x9d, 0xd1,
	0xd9, 0x64, 0x6c, 0xf2, 0xef, 0xd5, 0x71, 0x17, 0x1a, 0x67, 0x56, 0x87, 0x8c, 0xbb, 0x56, 0x67,
	0xac, 0x35, 0x0e, 0xff, 0xae, 0x81, 0xdc, 0xa3, 0xae, 0xcb, 0x6f, 0x39, 0x37, 0xff, 0xea, 0x8a,
	0xf6, 0xb7, 0x58, 0xdf, 0x24, 0x90, 0x19, 0xdf, 0xe6, 0x16, 0x2c, 0xd8, 0xde, 0x4e, 0x4d, 0x7f,
	0xb0, 0xcd, 0xf4, 0x26, 0x69, 0xe6, 0x96, 0xb7, 0xf1, 0x7d, 0xda, 0x66, 0xab, 0xa2, 0xcd, 0xbe,
	0xd8, 0x52, 0xb1, 0x7c, 0x5f, 0xc5, 0x2e, 0xfb, 0x0b, 0x34, 0xb2, 0x76, 0x99, 0x7a, 0xfd, 0x4d,
	0x19, 0x96, 0x95, 0x35, 0xc9, 0x19, 0x3c, 0x05, 0x25, 0x5e, 0xda, 0x34, 0x62, 0x69, 0x5b, 0x7a,
	0x55, 0x46, 0x4f, 0x84, 0x8a, 0xa4, 0x6a, 0xfc, 0x61, 0xb3, 0x33, 0xbd, 0x2e, 0x03, 0x37, 0x1b,
	0x93, 0xf1, 0x97, 0x04, 0x8d, 0x6c, 0x2f, 0x68, 0xc1, 0x7e, 0xec, 0x15, 0x3b, 0xf5, 0x94, 0x3b,
	0x2e, 0xd4, 0xa5, 0x56, 0xb5, 0xa4, 0xf8, 0x9e, 0xad, 0xeb, 0xf9, 0x7a, 0x88, 0x13, 0x78, 0xbe,
	0x91, 0x26, 0xd9, 0x68, 0xa8, 0x57, 0x44, 0xa2, 0xa7, 0xce, 0x75, 0xb0, 0x4e, 0x27, 0xab, 0xa1,
	0x71, 0x0a, 0x4a, 0x32, 0xc4, 0xaf, 0x41, 0x09, 0x23, 0x1a, 0xc5, 0xe1, 0x63, 0x1f, 0xf0, 0x1d,
	0x8c, 0x44, 0x8c, 0xa4, 0x9a, 0x6d, 0xa5, 0x51, 0xc9, 0x4b, 0xe3, 0xf0, 0xb7, 0x6d, 0xb6, 0xdf,
	0x85, 0x46, 0x66, 0xfb, 0xc4, 0xf5, 0x93, 0x6b, 0xb3, 0x33, 0xb6, 0xb4, 0x4a, 0xd1, 0xc7, 0xd5,
	0x75, 0xbb, 0xca, 0xdd, 0xb7, 0xf0, 0xc2, 0x0f, 0xe6, 0x6d, 0xba, 0xa4, 0xb3, 0x5b, 0xf6, 0xf8,
	0x94, 0x5d, 0xe5, 0x9a, 0xff, 0xcc, 0xc3, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x64, 0xb0, 0xdb,
	0x03, 0x07, 0x08, 0x00, 0x00,
}
